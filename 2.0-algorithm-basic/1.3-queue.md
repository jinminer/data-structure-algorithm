# 队列（queue）

* 先进者先出
* 队列只支持两个操作：
  * 入队 enqueue()，放一个数据到队列尾部；
  * 出队 dequeue()，从队列头部取一个元素。

* 是一种操作受限的线性表数据结构
* 队列需要两个指针：
  * 一个是 head 指针，指向队头；
  * 一个是 tail 指针，指向队尾。



## 顺序队列

### 定义

* 用数组实现的队列叫作顺序队列



## 链式队列

### 定义

* 用链表实现的队列叫作链式队列。



## 循环队列

* 首尾相连的数组，类似一个环，可以避免队列中队满的数据迁移问题
* 当循环队列满时，tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。



## 阻塞队列

* 在队列基础上增加了阻塞操作
* 在队列为空的时候，从队头取数据会被阻塞。
  * 此时还没有数据可取，直到队列中有了数据才能返回
* 如果队列已经满了，插入数据的操作就会被阻塞。
  * 直到队列中有空闲位置后再插入数据，然后再返回。
* 阻塞队列是生产者 - 消费者模型
  * 当多个消费者，即多个线程同时操作队列时，会存在线程安全问题



## 并发队列

* 线程安全的队列我们叫作并发队列
  * 使用加锁，CAS 原子操作等可以实现并发队列



## 请求排队

* 冗余请求处理
  * 非阻塞的处理方式：直接拒绝任务请求
  * 阻塞的处理方式：将请求排队，等到有空闲线程时，取出排队的请求继续处理。

* 队列实现阻塞
  * 基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
  * 基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。

* 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。


